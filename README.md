# prompt_detective

## ⚠️ 重要な法的免責事項・サービス変更について

**このプロジェクトは教育・技術デモンストレーション目的のみです。**

### 🔄 サービス仕様変更（2025年6月）

**賭博法抵触リスクを回避するため、以下の通りサービス仕様を変更いたします：**

- ❌ **変更前**: SOL（暗号資産）を用いた賭博形式のゲーム
- ✅ **変更後**: 換金性のないゲーム独自ポイントシステムを採用した完全無料サービス

**新仕様の詳細:**
- **ポイント制**: プレイヤーは無料で配布される独自ポイントを使用
- **無換金性**: ポイントは現金・暗号資産・その他価値あるものと交換不可
- **純粋なエンターテイメント**: AI画像のプロンプト推測を楽しむゲーム体験
- **学習要素**: AIとアートの理解を深める教育的側面

### 法的注意事項
- 日本国内での実際の暗号資産を用いた運用は賭博罪（刑法第185条・186条）に抵触する可能性があります
- 商用利用や実際の金銭・暗号資産の取引には適切な法的助言を受けてください
- 開発者は本コードの使用により生じる法的問題について責任を負いません

## concept

![26430](https://github.com/SatoshiRoppongi/prompt_detective/assets/12537347/00adf9cc-adfb-4545-ac8c-d44265a366e9)


### Claude Code 指示テンプレート：AI画像フレーズ推測ゲーム (Prompt Detective Game) 開発

---

**プロジェクト名:** AI画像フレーズ推測ゲーム (Prompt Detective Game)

**開発の目的:**
ユーザーがAIが生成した画像を見て、その元となった「隠されたフレーズ」を推測する分散型ゲームを開発する。最も正解に近い回答をしたユーザーに、参加者から集められた掛金が分配される。透明性と公平性を保ちつつ、ユーザー体験に優れたアプリケーションを提供する。

**システム概要:**

1.  **フレーズ自動生成:** システムがランダムな「隠されたフレーズ」を自動生成する。
2.  **画像生成:** 隠されたフレーズに基づき、AIが画像を生成する。
3.  **ユーザー推測:** ユーザーは画像を見て、隠されたフレーズを推測し、回答を送信する。
4.  **勝者決定と報酬分配:** 複数のユーザーの回答が集まった後、自動的に隠されたフレーズとユーザーの回答の類似度を評価し、最も類似度が高いユーザーを勝者とする。勝者には参加者の掛金がSolanaスマートコントラクトを通じて分配される。

**技術スタック:**

* **フロントエンド:** Nuxt 3 (TypeScript, Vue 3, Pinia)
* **バックエンド:** Firebase Functions (Node.js, TypeScript)
* **ブロックチェーン:** Solana (Rust, Anchor Framework)
* **画像生成AI:** 外部サービス (例: OpenAI DALL-E, Midjourney APIなど - API連携を想定)
* **フレーズ生成:** 中央集権型サーバー (Firebase Functions)
* **フレーズと回答の類似度評価:** 中央集権型サーバー (Firebase Functions - 例: doc2vecライブラリの利用を想定)

**主要機能とコンポーネントごとの詳細指示:**

---

#### 1. フロントエンド (Nuxt 3)

* **目的:** ユーザーインターフェースを提供し、ゲームの参加、画像表示、回答入力、ゲーム結果の表示を行う。Solanaウォレットとの連携を実装する。
* **UI/UXの要件:**
    * 直感的で分かりやすいインターフェース。
    * ゲームの現在の状態（進行中、回答募集終了、結果発表など）が明確に表示される。
    * Solanaウォレット接続（Phantomなど）がスムーズに行える。
* **主な画面/コンポーネント:**
    * **トップページ:**
        * ゲームの概要説明。
        * 「新しいゲームを開始する」ボタン (管理ユーザー向け、またはゲーム開始のトリガー)。
        * 現在進行中のゲーム一覧 (画像と残り時間、参加人数など)。
    * **ゲームプレイページ:**
        * 大きく表示されるAI生成画像。
        * 回答入力フォーム (テキストエリア)。
        * 掛金設定・表示、回答提出ボタン。
        * ゲームの残り時間表示。
        * （オプション）参加者のアバターや数。
    * **結果表示ページ:**
        * AIが生成した「隠されたフレーズ」の公開。
        * ユーザーの回答と、そのフレーズとの類似度スコア。
        * 全参加者の回答とスコアのランキング表示。
        * 勝者の表示と、獲得した掛金。
        * スマートコントラクトのトランザクションリンク。
    * **ウォレット接続コンポーネント:**
        * Solanaウォレット（Phantomなど）への接続機能。
        * ユーザーの公開鍵表示。
* **技術的な指示:**
    * Nuxt 3 の最新安定版を使用。
    * TypeScriptを全面的に適用。
    * 状態管理はPiniaを使用し、ユーザー情報、ゲーム状態、画像データなどを管理。
    * Firebase Functions とのAPI連携 (AxiosまたはFetch API)。
    * Solana Web3.js または `solana/wallet-adapter` を利用したウォレット連携。
    * SCSSまたはTailwind CSSでスタイリングを適用。

---

#### 2. バックエンド (Firebase Functions)

* **目的:** 隠されたフレーズの生成、AI画像生成のトリガー、ユーザー回答の受付と一時保存、フレーズと回答の類似度評価、Solanaスマートコントラクトへの連携（トリガー役）を担う。
* **主な機能:**
    * **`createGame` (HTTP Trigger):**
        * システムがランダムな「隠されたフレーズ」を自動生成するロジックを実装。
            * （例: 特定のテーマやキーワードリストからランダムに組み合わせる、または既存の文章を加工するなど、フレーズ生成の具体的なロジックを考慮）
        * 生成したフレーズをDBに隠蔽して保存。
        * このフレーズを画像生成AI (例: DALL-E API) に渡し、画像を生成させる。
        * 生成された画像のURLを保存。
        * 新しいゲームのステータスと画像をDBに記録し、ゲームIDを生成。
        * フロントエンドにゲーム情報を返す。
    * **`submitAnswer` (HTTP Trigger):**
        * ユーザーから送信された回答テキストとゲームID、ユーザーのSolana公開鍵を受け取る。
        * 回答をDBに一時保存。
        * 参加者の掛金をスマートコントラクトに送金させるためのトリガー（例: クライアント側でトランザクションを構築させ、Firebase Functionsにシグネチャを送信させる、またはFirebase Functionsがスマートコントラクトと直接やり取りするGateway的な役割）。
    * **`endGameAndEvaluate` (Scheduled Trigger / HTTP Trigger for Admin):**
        * ゲームの回答募集期間が終了した際にトリガーされる。
        * DBから隠されたフレーズと全ユーザーの回答を取得。
        * **類似度評価ロジックを実装 (重要):**
            * 例: `doc2vec` ライブラリ（Pythonで実装し、Firebase Functionsから呼び出すか、Node.jsで類似のライブラリを探す）を利用し、隠されたフレーズと各ユーザーの回答の間の類似度スコアを算出。
            * スコアに基づいてランキングを作成。
        * 勝者を決定。
        * **Solanaスマートコントラクトへの勝者情報と報酬分配トリガー:**
            * スマートコントラクトの `distribute_winnings` 関数などを呼び出すための必要なデータ（勝者の公開鍵、分配額、ゲームIDなど）を準備し、トランザクションを構築する。
            * （Firebase Functionsが直接Solanaトランザクションに署名するか、管理者からの手動確認プロセスを挟むか、設計を検討）
        * ゲーム結果をDBに保存し、フロントエンドに公開する準備をする。
    * **データベース:** Firestore (ゲームの状態、隠されたフレーズ、画像URL、ユーザーの回答、スコアなどを保存)
* **技術的な指示:**
    * TypeScriptを使用。
    * Node.js ランタイム。
    * Firebase Admin SDK を使用してFirestoreと連携。
    * AI画像生成APIの利用（APIキーのセキュアな管理）。
    * Solana Web3.js または類似のライブラリを使用してスマートコントラクトと連携。
    * **セキュリティとエラーハンドリングを重視する。** 特にSolanaトランザクション関連。

---

#### 3. ブロックチェーン (Solana / Rust / Anchor Framework)

* **目的:** ゲームの掛金管理、参加者の登録、勝者への報酬の公平かつ透明な分配を担う。
* **プログラム（コントラクト）名:** `prompt_detective_game` (仮)
* **主な機能:**
    * **`initialize_game`:**
        * 新しいゲームのアカウントを初期化。
        * ゲームのステータス（募集期間、掛金など）を管理する状態を定義。
        * （オプション）ゲーム作成者（管理者）が掛金プール初期化のためにSOLを転送する仕組み。
    * **`join_game`:**
        * ユーザーがゲームに参加するための関数。
        * 指定された掛金（例: X SOL）をユーザーのアカウントから引き落とし、ゲームの掛金プールアカウントに転送する。
        * 参加者の公開鍵をゲームのアカウントに記録（またはFirebase Functions側で管理し、最終的な分配時にのみSolanaに渡す）。
        * 参加者ごとの解答権限を付与（オプション）。
    * **`distribute_winnings`:**
        * ゲーム終了後、Firebase Functionsからのトリガーを受けて呼び出される。
        * 勝者の公開鍵と分配額を受け取る。
        * 掛金プールアカウントから勝者のアカウントへSOLを安全に転送する。
        * 手数料（プロトコル手数料など）の徴収ロジックを実装することも可能。
        * **重要:** この関数が「隠されたフレーズ」を知る必要はない。Firebase Functionsが勝者を決定し、Solanaは分配のみを行う。
* **アカウント設計の考慮点:**
    * `Game` アカウント: ゲームの状態、掛金プール、募集期間、参加者数などを格納。
    * `PlayerAnswer` アカウント (オプション): 各プレイヤーの参加と回答の状態を追跡（Firebase Functionsで管理する方が柔軟性があるかもしれない）。
* **技術的な指示:**
    * Rust言語とAnchor Frameworkを使用。
    * セキュリティ（Re-entrancy Guard, CPI Guardなど）と効率性を最優先。
    * Solanaプログラムのテストコードを徹底的に記述する。
    * エラーハンドリングを明確にする。
    * CLIツール (Anchor CLI) でビルド・デプロイ・テストができるようにする。

---

**全体的な考慮事項:**

* **データフロー:** フロントエンド ⇔ Firebase Functions ⇔ Solana スマートコントラクト のデータと制御の流れを明確にする。
* **エラーハンドリングとリカバリ:** 各層でのエラー発生時の挙動と、データの一貫性を保つための戦略を考慮する。
* **セキュリティ:** APIキーの管理、Solanaトランザクションの署名と検証、ユーザー入力のサニタイズなど。
* **スケーラビリティ:** Firebase FunctionsとSolanaは高スケーラブルだが、画像生成AIのAPIレートリミットや、類似度評価の処理負荷などを考慮する。
* **ゲームのライフサイクル:** ゲームの開始、回答募集、終了、結果発表、次のゲーム開始への移行を明確な状態遷移で管理する。

**Claude Codeへの依頼事項:**

上記の要件に基づき、Nuxt 3 (フロントエンド)、Firebase Functions (バックエンド)、Solana/Rust/Anchor (ブロックチェーン) の各コンポーネントについて、具体的に実装してください。
各技術スタックのベストプラクティスを遵守したコードで実装してください

claude codeへの指示はここまで。

# 環境構築

## envファイルのコピー

```
cd front
cp .env.local .env
```
